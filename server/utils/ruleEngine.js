const {
    SIGNS,
    NAKSHATRAS,
    PLANET_INFO,
    calculateSign,
    calculateNakshatra,
    calculateDignity,
    calculatePlanetaryPositions
} = require('./astroCalculator');

/**
 * Helper to get Planet Info from a Chart
 * Chart structure: { planets: { Sun: 123.4, ... }, ascendant: ... }
 */
const getPlanetPosition = (planetName, chart) => {
    // If planetName is Rasi Lord (e.g. "Mars"), we just look up "Mars" in planets.
    // chart.planets is object with { PlanetName: longitude }
    // We should return standardized info including Sign ID, Nakshatra, etc.
    const long = chart.planets[planetName];
    if (long === undefined) return null;

    const sign = calculateSign(long);
    const nak = calculateNakshatra(long);
    return {
        name: planetName,
        longitude: long,
        signId: sign.id,
        signLord: sign.lord,
        nakshatraName: nak.name,
        nakshatraLord: nak.lord
    };
};

/**
 * Helper to check if two planets are conjoined (in same Sign)
 */
const isConjoined = (pos1, pos2) => {
    if (!pos1 || !pos2) return false;
    return pos1.signId === pos2.signId;
};

/**
 * Helper to check if a planet is in a list of Signs (owned by someone)
 */
const isInSigns = (planetPos, signsList) => {
    if (!planetPos || !signsList) return false;
    return signsList.includes(planetPos.signId);
};

/**
 * Helper to check ownership/exalted status
 * Note: calculateDignity returns this info based on chart
 */
const getQuality = (planetName, longitude) => {
    const dignity = calculateDignity(planetName, longitude);
    return dignity.english; // 'Exalted', 'Own Sign', 'Friendly', etc.
};

const getSignOwner = (signId) => {
    const s = SIGNS.find(s => s.id === signId);
    return s ? s.lord : null;
};

const getPlanetOwnedSigns = (planetName) => {
    if (!planetName || !PLANET_INFO[planetName]) return [];
    return PLANET_INFO[planetName].own;
};

/**
 * Main Rule Engine Function
 * @param {Object} playerChart - Full structure from DB (birthChart.planets)
 * @param {Object} matchChart - Generated by calculatePlanetaryPositions + helpers
 */
const evaluatePrediction = async (playerBirthChart, matchDateParams) => {
    const logs = [];

    // 1. Generate Match Chart
    // matchDateParams: { year, month, day, hour, minute, latitude, longitude, timezone }
    const { planets: matchPlanets, ascendant: matchAscendantLng } = calculatePlanetaryPositions(
        matchDateParams.year, matchDateParams.month, matchDateParams.day,
        matchDateParams.hour, matchDateParams.minute,
        matchDateParams.latitude, matchDateParams.longitude, matchDateParams.timezone
    );

    // Normalize Match Chart access
    const matchChart = {
        planets: matchPlanets,
        ascendant: matchAscendantLng,
        // Pre-calc Moon details for quick access
        moon: getPlanetPosition('Moon', { planets: matchPlanets }),
        ascendantDetails: calculateSign(matchAscendantLng)
    };

    // Normalize Player Chart access
    // Player chart from DB might be nested. `playerBirthChart.planets` { Sun: { longitude: ... } } OR { Sun: 123 }
    // Based on playerController, it stores full breakdown.
    // The internal helper `getPlanetPosition` expects { Sun: longitude } map.
    // Let's create a simple map for Player
    const playerMap = {};
    const rawPlayerPlanets = playerBirthChart.planets || {};
    for (const [k, v] of Object.entries(rawPlayerPlanets)) {
        // v might be object { longitude: 123 } or number 123
        playerMap[k] = (typeof v === 'object' && v.longitude !== undefined) ? v.longitude : v;
    }
    const playerChart = {
        planets: playerMap,
        moon: getPlanetPosition('Moon', { planets: playerMap })
    };


    // BASIC DATA EXTRACTION
    // Player Info
    const playerMoon = playerChart.moon;
    const playerRasi = playerMoon.signId; // 1-12
    const playerRasiLord = playerMoon.signLord; // Planet Name
    const playerStar = playerMoon.nakshatraName;
    const playerStarLord = playerMoon.nakshatraLord;

    // Match Info
    const matchMoon = matchChart.moon;
    const matchRasi = matchMoon.signId;
    const matchRasiLord = matchMoon.signLord;
    const matchStar = matchMoon.nakshatraName;
    const matchStarLord = matchMoon.nakshatraLord;
    const matchLagnaLord = matchChart.ascendantDetails.lord;

    logs.push(`Player: Rasi=${playerMoon.signId}(${playerRasiLord}), Star=${playerStar}(${playerStarLord})`);
    logs.push(`Match: Rasi=${matchRasi}(${matchRasiLord}), Star=${matchStar}(${matchStarLord}), LagnaLord=${matchLagnaLord}`);

    // POSITIONS IN MATCH CHART (TRANSIT)
    // Where are the key lords NOW?
    const matchStarLordPos = getPlanetPosition(matchStarLord, matchChart);
    const playerRasiLordPos = getPlanetPosition(playerRasiLord, matchChart);
    const playerStarLordPos = getPlanetPosition(playerStarLord, matchChart);
    const matchRasiLordPos = getPlanetPosition(matchRasiLord, matchChart);
    const matchLagnaLordPos = getPlanetPosition(matchLagnaLord, matchChart);

    // BATTING RULES
    let battingScore = 0;
    const battingRules = [];
    let battingStatus = "FLOP"; // Default

    // Rule 1: Main
    // Connection of Match Star Lord with Player Rasi Lord OR Player Star Lord
    const r1_conjoinedRasi = isConjoined(matchStarLordPos, playerRasiLordPos);
    const r1_conjoinedStar = isConjoined(matchStarLordPos, playerStarLordPos);

    // Helper for Exchange (Parivarthana) Check based on Chart context
    const checkExchange = (planetName, planetPos, chartContext) => {
        const dispositorName = planetPos.signLord;
        if (!dispositorName || dispositorName === planetName) return false;
        const dispositorPos = getPlanetPosition(dispositorName, chartContext);
        if (!dispositorPos) return false;
        return dispositorPos.signLord === planetName;
    };

    if (r1_conjoinedRasi || r1_conjoinedStar) {
        let r1_excellent = false;
        const lordDignity = getQuality(matchStarLord, matchStarLordPos.longitude);
        if (['Exalted', 'Own Sign', 'Mooltrikona'].includes(lordDignity)) {
            r1_excellent = true;
        } else if (checkExchange(matchStarLord, matchStarLordPos, matchChart)) {
            r1_excellent = true;
        }

        if (r1_excellent) {
            battingScore += 3;
            battingRules.push("Rule 1 (Excellent): Star Lord Conjoined & Strong");
        } else {
            battingScore += 1;
            battingRules.push("Rule 1 (Good): Star Lord Conjoined");
        }
    }

    // Rule 2: Match & Player Same Rasi + Star
    // "One and the same"
    const r2_same = (matchRasi === playerRasi) && (matchStar === playerStar);
    if (r2_same) {
        battingScore += 1;
        battingRules.push("Rule 2 (Good): Same Rasi & Star");
        // Bowling Flop Trigger
        // We'll handle bowling later, but note this.
    }

    // Rule 3: Lord House Rule
    // Player Rasi Lord AND Star Lord BOTH in Match Star Lord's owned signs
    const starLordOwnedSigns = getPlanetOwnedSigns(matchStarLord);
    const r3_rasiIn = isInSigns(playerRasiLordPos, starLordOwnedSigns);
    const r3_starIn = isInSigns(playerStarLordPos, starLordOwnedSigns);
    if (r3_rasiIn && r3_starIn) {
        battingScore += 1;
        battingRules.push("Rule 3 (Good): Lords in Star Lord's House");
    }

    // Rule 4: Fallback (Only if 1, 2, 3 Fail)
    // I will calculate it anyway, but apply only if others failed?
    // "Rule 4... If 1, 2, 3 none match"
    // I'll store the potential score and add it at end if needed.
    let r4_applies = false;
    if (battingRules.length === 0) {
        // Player Rasi Lord OR Star Lord IS LOCATED IN SIGN X.
        // Match Rasi Lord AND Match Star Lord CONJOINED IN X.
        const targetSignRasi = playerRasiLordPos.signId;
        const targetSignStar = playerStarLordPos.signId;

        const matchLordsConjoined = isConjoined(matchRasiLordPos, matchStarLordPos);
        if (matchLordsConjoined) {
            if (matchRasiLordPos.signId === targetSignRasi || matchRasiLordPos.signId === targetSignStar) {
                r4_applies = true;
            }
        }
        if (r4_applies) {
            // It says "Fallback... -> GOOD"
            battingScore += 1;
            battingRules.push("Rule 4 (Fallback/Good): Match Lords Conjoined in Player Loc");
        }
    }

    // Rule 5: Additional Support
    // Player Rasi Lord conjoined with Match Star Lord
    // Wait, Rule 1 covered "Match Star Lord with Player Rasi Lord -> GOOD".
    // Rule 5 says the same. "Player Rasi Lord ... with Match Star Lord ... -> GOOD".
    // Maybe Rule 1 implies "Player Rasi Lord OR Star Lord".
    // Rule 5 might be redundant or additive. I will treat as additive or reinforcement.
    // If Rule 1 (Rasi part) triggered, Rule 5 is same.
    // I won't double count if it's the exact same condition.
    if (!battingRules.some(r => r.includes("Rule 1")) && isConjoined(playerRasiLordPos, matchStarLordPos)) {
        battingScore += 1;
        battingRules.push("Rule 5 (Good): Player Rasi Lord conjoined Match Star Lord");
    }

    // Rule 6: Rahu/Ketu Special
    if (['Rahu', 'Ketu'].includes(playerStarLord)) {
        // Player Rasi Lord in Match Star Lord House -> GOOD
        // Else FLOP
        const r6_good = isInSigns(playerRasiLordPos, starLordOwnedSigns); // Reuse starLordOwnedSigns
        if (r6_good) {
            battingScore += 1;
            battingRules.push("Rule 6 (Good): Rahu/Ketu Special");
        } else {
            // Else FLOP. Does this mean override everything to FLOP?
            // "Else -> FLOP". Usually specific rules override general.
            // But if user has Good score from others?
            // I'll treat as -1.
            battingScore -= 1;
            battingRules.push("Rule 6 (Flop): Rahu/Ketu Special Failed");
        }
    }

    // Final Flop Rule
    // If 1-6 None matched
    if (battingRules.length === 0) {
        battingScore = -1;
        battingRules.push("Flop Rule: No rules matched");
    }


    // BOWLING RULES
    let bowlingScore = 0;
    const bowlingRules = [];

    // Rule 1
    // Player Rasi+Star conjoined with Match Moon Rasi+Star
    // "Conjoined" usually means same sign (Rasi).
    // If Match Rasi == Player Rasi.
    if (matchRasi === playerRasi) {
        // Check for Exchange/Exalted/Own (Excellent)
        // Player Rasi Lord position dignity
        const pRasiLordDignity = getQuality(playerRasiLord, playerRasiLordPos.longitude);
        let b1_excellent = false;

        if (['Exalted', 'Own Sign'].includes(pRasiLordDignity)) {
            b1_excellent = true;
        } else if (checkExchange(playerRasiLord, playerRasiLordPos, matchChart)) {
            // Note: Checking exchange in Match Chart context (Transit)
            b1_excellent = true;
        }

        if (b1_excellent) {
            bowlingScore += 3;
            bowlingRules.push("Rule 1 (Excellent): Rasi Conjoined & Strong");
        } else {
            bowlingScore += 1;
            bowlingRules.push("Rule 1 (Good): Rasi Conjoined");
        }
    }

    // Batting Rule 2 Impact: "Bowling SURE FLOP"
    if (r2_same) {
        bowlingScore = -1;
        bowlingRules.push("Batting Rule 2 Impact: SURE FLOP for Bowling");
    }

    // Rule 2
    // Match Moon Star Lord owns Signs [X, Y].
    // Player Rasi Lord OR Player Star Lord is IN X or Y.
    const matchMoonStarLordOwned = getPlanetOwnedSigns(matchStarLord);
    if (isInSigns(playerRasiLordPos, matchMoonStarLordOwned) || isInSigns(playerStarLordPos, matchMoonStarLordOwned)) {
        bowlingScore += 1;
        bowlingRules.push("Rule 2 (Good): Lords in Moon Star Lord House");
    }

    // Rule 3: Lagna Special
    // Match Rasi Lord == Match Lagna Lord
    if (matchRasiLord === matchLagnaLord) {
        // Player Rasi Lord OR Star Lord == Match Lagna Lord
        if (playerRasiLord === matchLagnaLord || playerStarLord === matchLagnaLord) {
            bowlingScore += 3;
            bowlingRules.push("Rule 3 (Excellent): Lagna Lord Match");
        }
    }

    // Rule 4
    // Player Rasi+Star (Sign) IN Match Rasi Lord House OR Match Star Lord House
    // Usually "Player Rasi is in..."
    const matchRasiLordOwned = getPlanetOwnedSigns(matchRasiLord);
    const matchStarLordOwned = getPlanetOwnedSigns(matchStarLord);
    const playerRasiIsOwnedByMatchRasiLord = matchRasiLordOwned.includes(playerRasi);
    const playerRasiIsOwnedByMatchStarLord = matchStarLordOwned.includes(playerRasi);

    if (playerRasiIsOwnedByMatchRasiLord || playerRasiIsOwnedByMatchStarLord) {
        bowlingScore += 1;
        bowlingRules.push("Rule 4 (Good): Player Rasi in Match Lords House");
    } else {
        // Else FLOP. -1?
        // Usually "Else Flop" implies penalty or failure if this rule was evaluated.
        // It says "Rule 4... If not -> FLOP".
        // This is strong. Does it override others?
        // I will accumulate usually.
        bowlingScore -= 1;
        bowlingRules.push("Rule 4 (Flop): Not in Match Lords House");
    }

    // Rule 5
    // Player Rasi Lord IN Match Lagna (Sign) -> EXCELLENT
    // Match Lagna Sign ID = matchChart.ascendantDetails.id
    if (playerRasiLordPos.signId === matchChart.ascendantDetails.id) {
        bowlingScore += 3;
        bowlingRules.push("Rule 5 (Excellent): Rasi Lord in Match Lagna");
    }

    // Rule 6
    // Player Rasi Lord conjoined Match Lagna Lord -> EXCELLENT
    if (isConjoined(playerRasiLordPos, matchLagnaLordPos)) {
        bowlingScore += 3;
        bowlingRules.push("Rule 6 (Excellent): Rasi Lord conjoined Lagna Lord");
    }

    return {
        batting: {
            score: battingScore,
            status: battingScore > 0 ? "GOOD" : (battingScore < 0 ? "FLOP" : "NEUTRAL"),
            rules: battingRules
        },
        bowling: {
            score: bowlingScore,
            status: bowlingScore > 0 ? "GOOD" : (bowlingScore < 0 ? "FLOP" : "NEUTRAL"),
            rules: bowlingRules
        },
        logs
    };
};

module.exports = { evaluatePrediction };
